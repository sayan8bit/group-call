<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>PeerJS Group Video + Chat (Static)</title>
    <style>
      /* (unchanged styling from your file) */
      :root {
        --bg: #0f1724;
        --card: #0b1220;
        --muted: #9aa6b2;
        --accent: #06b6d4;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Inter, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
        background: linear-gradient(180deg, #071024 0%, #071528 100%);
        color: #e6eef6;
      }
      header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.02);
        backdrop-filter: blur(6px);
      }
      header h1 {
        font-size: 16px;
        margin: 0;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 12px;
        padding: 12px;
        height: calc(100vh - 64px);
      }
      .video-area {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          transparent
        );
        border-radius: 10px;
        padding: 10px;
        display: flex;
        flex-direction: column;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      .room-info {
        font-size: 13px;
        color: var(--muted);
      }
      button,
      input,
      textarea {
        font: inherit;
      }
      .btn {
        background: var(--accent);
        border: none;
        color: #022;
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      .btn.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: var(--muted);
      }
      #videos {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 8px;
        align-content: start;
        overflow: auto;
        padding: 6px;
      }
      video {
        width: 100%;
        height: 150px;
        object-fit: cover;
        border-radius: 8px;
        background: #000;
      }
      .panel {
        background: rgba(255, 255, 255, 0.02);
        border-radius: 8px;
        padding: 10px;
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .chat {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow: auto;
        padding: 6px;
      }
      .message {
        padding: 6px;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.25);
        font-size: 14px;
      }
      .my {
        background: linear-gradient(90deg, #083344, #044b5b);
        color: #cfecef;
      }
      .input-row {
        display: flex;
        gap: 8px;
      }
      input[type="text"] {
        flex: 1;
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: inherit;
      }
      .small {
        font-size: 12px;
        color: var(--muted);
      }
      .peer-id {
        font-family: monospace;
        font-size: 13px;
      }
      footer {
        padding: 8px 12px;
        font-size: 13px;
        color: var(--muted);
      }
      @media (max-width: 900px) {
        .container {
          grid-template-columns: 1fr;
          grid-auto-rows: auto;
          height: auto;
        }
        .panel {
          height: 300px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>PeerJS Group Video + Chat — Static</h1>
      <div class="room-info" id="roomText">Initializing...</div>
    </header>

    <div class="container">
      <div class="video-area panel">
        <div class="controls">
          <div style="flex: 1">
            <div class="small">
              Your Peer ID: <span class="peer-id" id="myId">—</span>
            </div>
            <div class="small">Room: <span id="roomIdDisplay">—</span></div>
          </div>
          <button class="btn" id="toggleVideo">Toggle Video</button>
          <button class="btn secondary" id="copyLink">Copy Room Link</button>
          <button class="btn secondary" id="leaveBtn">Leave</button>
        </div>

        <div id="videos"></div>
        <div class="small" style="margin-top: 6px">
          Notes: This is a peer-to-peer mesh. Max 5 participants. If host
          leaves, others may continue, but new joiners need the host or a new
          introducer.
        </div>
      </div>

      <div class="panel">
        <div
          style="
            display: flex;
            align-items: center;
            justify-content: space-between;
          "
        >
          <div><strong>Chat</strong></div>
          <div class="small">Participants: <span id="count">0</span></div>
        </div>
        <div class="chat" id="chat"></div>
        <div class="input-row" style="margin-top: 8px">
          <input
            id="chatInput"
            type="text"
            placeholder="Type message and press Enter"
          />
          <button class="btn" id="sendBtn">Send</button>
        </div>
      </div>
    </div>

    <footer>
      To host: push this single file to GitHub Pages. Share link with others —
      the room id is in the URL hash (example:
      <span class="peer-id">#room=my-room</span>).
    </footer>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
      /******************************
       Group mesh improvements:
       - deterministic initiator rule: only peer with smaller id initiates conn+call
         (prevents double connections and duplicate messages)
       - host (room-host) introduces existing participant ids to newcomers
       - participants connect to each other using above rule
       - on leave/close, remove video and update count
       - MAX_PARTICIPANTS limit (5)
      *******************************/

      const MAX_PARTICIPANTS = 5;

      const urlRoom = (() => {
        const hash = location.hash.replace("#", "");
        if (!hash) return null;
        const m = hash.match(/room=(.*)/);
        return m ? m[1] : hash;
      })();

      let room = urlRoom || Math.random().toString(36).slice(2, 9);
      if (!urlRoom) location.hash = "room=" + room;

      const hostId = room + "-host";
      const videosEl = document.getElementById("videos");
      const myIdEl = document.getElementById("myId");
      const roomIdDisplay = document.getElementById("roomIdDisplay");
      const roomText = document.getElementById("roomText");
      const chatEl = document.getElementById("chat");
      const countEl = document.getElementById("count");
      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");
      const copyLinkBtn = document.getElementById("copyLink");
      const toggleVideoBtn = document.getElementById("toggleVideo");
      const leaveBtn = document.getElementById("leaveBtn");

      roomIdDisplay.textContent = room;
      roomText.textContent = "Room: " + room + " — share this link";

      let localStream = null;
      let peer = null;
      let myId = null;
      let isHost = false;

      // Track state (media and data connections) for cleanup and display
      // Structure: participants[id] = { dataConn?: DataConnection, call?: MediaConnection }
      const participants = {};

      // helper: lexicographic comparison: returns true if myId should initiate to otherId
      function shouldInitiateTo(otherId) {
        if (!myId || !otherId) return false;
        return myId < otherId; // deterministic: smaller id initiates
      }

      async function initLocalMedia() {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          addVideoStream("me", localStream, true);
        } catch (e) {
          console.warn("getUserMedia failed", e);
        }
      }

      function addVideoStream(id, stream, isLocal = false) {
        let v = document.getElementById("vid-" + id);
        if (!v) {
          v = document.createElement("video");
          v.id = "vid-" + id;
          v.autoplay = true;
          v.playsInline = true;
          if (isLocal) v.muted = true;
          videosEl.appendChild(v);
        }
        v.srcObject = stream;
      }

      function removeVideo(id) {
        const v = document.getElementById("vid-" + id);
        if (v) {
          v.srcObject = null;
          v.remove();
        }
      }

      function appendChat(text, cls) {
        const d = document.createElement("div");
        d.className = "message" + (cls ? " " + cls : "");
        d.textContent = text;
        chatEl.appendChild(d);
        chatEl.scrollTop = chatEl.scrollHeight;
      }

      function updateCount() {
        let count = 1; // me
        try {
          // peer.connections contains arrays of DataConnection objects keyed by peer id
          if (peer && peer.connections)
            count = 1 + Object.keys(peer.connections).length;
        } catch (e) {}
        if (count > MAX_PARTICIPANTS) count = MAX_PARTICIPANTS;
        countEl.textContent = count;
      }

      // send a data message to every connected peer (one dataConn per pair due to initiator rule)
      function sendToAll(data) {
        if (!peer || !peer.connections) return;
        Object.keys(peer.connections).forEach((pid) => {
          // each entry is an array of connections; pick open ones and send
          peer.connections[pid].forEach((conn) => {
            try {
              if (conn.open) conn.send(data);
            } catch (e) {}
          });
        });
      }

      // Create Peer with PeerJS public cloud
      function createPeer(desiredId = null) {
        const opts = { host: "0.peerjs.com", port: 443, path: "/" };
        peer = desiredId
          ? new Peer(desiredId, opts)
          : new Peer(undefined, opts);

        peer.on("open", (id) => {
          myId = id;
          myIdEl.textContent = id;
          appendChat("System: connected as " + id, "small");
          updateCount();
          // if not host, try intro via host
          if (!isHost) tryConnectToHost();
        });

        // When remote calls us with media, answer and attach stream
        peer.on("call", (call) => {
          // answer with our localStream (may be null if user denied)
          try {
            call.answer(localStream);
          } catch (e) {}
          call.on("stream", (remoteStream) => {
            addVideoStream(call.peer, remoteStream);
          });
          call.on("close", () => {
            removeVideo(call.peer);
          });
          // store call for cleanup
          participants[call.peer] = {
            ...(participants[call.peer] || {}),
            call,
          };
          updateCount();
        });

        // When a data connection arrives (remote initiated)
        peer.on("connection", (conn) => {
          setupDataConn(conn, false); // remote-initiated => false
        });

        peer.on("disconnected", () =>
          appendChat("System: disconnected", "small")
        );
        peer.on("error", (err) => console.error("peer error", err));
      }

      // connInitiatedLocally: true when we (this client) created the connection
      function setupDataConn(conn, connInitiatedLocally) {
        const id = conn.peer;

        // ensure we don't create duplicate listeners for same conn
        conn.on("open", () => {
          participants[id] = { ...(participants[id] || {}), dataConn: conn };
          updateCount();
        });

        conn.on("data", (data) => {
          if (!data || !data.type) return;

          if (data.type === "chat") {
            // display chat only on receivers; sender already appended locally
            if (data.from !== myId) appendChat(data.from + ": " + data.text);
          }

          if (data.type === "introduce") {
            // host sent list of ids (string array). Connect to everyone in list using initiator rule.
            if (Array.isArray(data.ids)) {
              data.ids.forEach((otherId) => {
                if (otherId === myId) return;
                // ignore if already connected
                if (peer.connections && peer.connections[otherId]) return;
                // host may include many ids; only connect if we should initiate
                if (shouldInitiateTo(otherId)) connectToPeer(otherId);
              });
            }
          }

          if (data.type === "announce") {
            // a peer announced itself to everyone; we may connect based on rule
            const newId = data.id;
            if (newId === myId) return;
            if (peer.connections && peer.connections[newId]) return;
            if (shouldInitiateTo(newId)) connectToPeer(newId);
          }

          if (data.type === "host-full") {
            // host says room is full
            appendChat(
              "System: room is full (max " +
                MAX_PARTICIPANTS +
                " participants)",
              "small"
            );
            try {
              conn.close();
            } catch (e) {}
          }
        });

        conn.on("close", () => {
          // remove participant references
          delete participants[id];
          removeVideo(id);
          updateCount();
        });

        conn.on("error", (e) => {
          // cleanup on error
          delete participants[id];
          removeVideo(id);
          updateCount();
        });

        // If we initiated the connection we also (to be safe) tell the remote our presence by sending announce
        if (connInitiatedLocally) {
          try {
            conn.send({ type: "announce", id: myId });
          } catch (e) {}
        }
      }

      // Connect to a peer: create a data connection and, if we should, also call their media
      function connectToPeer(id) {
        if (!peer || id === myId) return;
        // if connection already exists, do nothing
        if (peer.connections && peer.connections[id]) return;

        // Safety: enforce max participants (current connections + me)
        const currentCount =
          peer && peer.connections
            ? 1 + Object.keys(peer.connections).length
            : 1;
        if (currentCount >= MAX_PARTICIPANTS) {
          console.warn("Max participants reached; skipping connection to", id);
          return;
        }

        // create data connection (we initiate)
        const conn = peer.connect(id, { reliable: true });
        // mark that this connection was initiated locally; setupDataConn will send announce as well
        conn.on("open", () => {
          setupDataConn(conn, true);
          // Now decide whether to start the media call. Only one side should call; use same deterministic rule
          if (shouldInitiateTo(id)) {
            if (localStream) {
              const call = peer.call(id, localStream);
              call.on("stream", (rs) => addVideoStream(id, rs));
              call.on("close", () => removeVideo(id));
              participants[id] = { ...(participants[id] || {}), call };
            }
          }
          updateCount();
        });
        conn.on("error", (e) => {
          console.warn("connect error to", id, e);
          delete participants[id];
          removeVideo(id);
          updateCount();
        });
      }

      // Try to contact host; if no host responds in TIMEOUT_MS, become host
      function tryConnectToHost() {
        if (!peer) return;
        const TIMEOUT_MS = 4500;
        const conn = peer.connect(hostId, { reliable: true });
        let timedOut = false;
        const to = setTimeout(() => {
          timedOut = true;
          try {
            conn.close();
          } catch (e) {}
          attemptBecomeHost();
        }, TIMEOUT_MS);

        conn.on("open", () => {
          clearTimeout(to);
          if (timedOut) return;
          // connected to host, ask for introduction
          setupDataConn(conn, false);
          try {
            conn.send({ type: "introduce", id: myId });
          } catch (e) {}
        });

        conn.on("error", (e) => {
          clearTimeout(to);
          attemptBecomeHost();
        });
      }

      // Become the host: re-create peer with hostId and accept newcomers.
      // Host will send introductions and handle "full" logic.
      function attemptBecomeHost() {
        if (isHost) return;
        appendChat("System: becoming host (introducer)", "small");

        // destroy old peer cleanly and re-create as host
        try {
          peer.disconnect();
          peer.destroy();
        } catch (e) {}
        isHost = true;
        createPeer(hostId);

        // when newcomer connects to host, introduce them to everyone and vice versa
        peer.on("connection", (conn) => {
          // If room is full, tell newcomer and close
          const currentParticipants =
            peer && peer.connections
              ? 1 + Object.keys(peer.connections).length
              : 1;
          if (currentParticipants > MAX_PARTICIPANTS) {
            try {
              conn.on("open", () => conn.send({ type: "host-full" }));
            } catch (e) {}
            try {
              conn.close();
            } catch (e) {}
            return;
          }

          // Setup connection normally
          setupDataConn(conn, false);

          conn.on("open", () => {
            // build list of existing participant ids except the newcomer
            let ids = [];
            try {
              ids = Object.keys(peer.connections).filter(
                (x) => x && x !== conn.peer
              );
            } catch (e) {}
            // send introduce list
            try {
              conn.send({ type: "introduce", ids });
            } catch (e) {}
            // announce newcomer to everyone else (they will choose whether to connect)
            sendToAll({ type: "announce", id: conn.peer });
          });
        });
      }

      // UI handlers
      sendBtn.onclick = () => {
        const t = chatInput.value.trim();
        if (!t) return;
        // append locally
        appendChat("Me: " + t, "my");
        // broadcast to all (others will display)
        sendToAll({ type: "chat", text: t, from: myId });
        chatInput.value = "";
      };
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") sendBtn.click();
      });

      copyLinkBtn.onclick = () => {
        navigator.clipboard.writeText(location.href).then(() => {
          copyLinkBtn.textContent = "Copied!";
          setTimeout(() => (copyLinkBtn.textContent = "Copy Room Link"), 1200);
        });
      };

      toggleVideoBtn.onclick = () => {
        if (!localStream) return;
        const track = localStream.getVideoTracks()[0];
        if (!track) return;
        track.enabled = !track.enabled;
        toggleVideoBtn.textContent = track.enabled
          ? "Turn Off Video"
          : "Turn On Video";
      };

      leaveBtn.onclick = () => {
        try {
          peer.disconnect();
          peer.destroy();
        } catch (e) {}
        appendChat("You left the room", "small");
        setTimeout(() => location.reload(), 500);
      };

      // start
      (async () => {
        await initLocalMedia();
        createPeer();
      })();
    </script>
  </body>
</html>
<!-- perfect -->
